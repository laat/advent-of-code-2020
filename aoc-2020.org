#+title: Advent Of Code 2020
#+PROPERTY: header-args:emacs-lisp :lexical yes

Using [[https://orgmode.org/][org-mode]] and Emacs Lisp to solve Advent of Code.

* Helpers

#+html: <details> <summary>Click to expand!</summary>
#+begin_src emacs-lisp
  ;; common-lisp emulation
  (require 'cl-lib)

  ;; awesome utils
  (require 'dash)
  (require 's)

  ;; still no tco in elisp. HACK!
  (setq max-lisp-eval-depth 10000)
  (setq max-specpdl-size 32000)

  (defun laat/cross (a b)
    (mapcan (lambda (x) (mapcar (lambda (y) (list x y)) b)) a))

  (defun laat/range (len)
    (cl-loop for i below len collect i))

  (defun laat/string-to-char (str)
    (mapcar 'identity str))

  (defun laat/make-dict (kv-list &rest htargs)
    (cl-loop with dict = (apply 'make-hash-table htargs)
             for (k v) in kv-list
             do (puthash k v dict)
             finally return dict))

  (defun laat/read-file (file-name)
    (with-temp-buffer
      (insert-file-contents file-name)
      (buffer-string)))

  (defun laat/read-lines (file-name)
    (split-string (laat/read-file file-name) "\n" t))
#+end_src

#+RESULTS:
: laat/read-lines

#+html: </details>

* Day 15

#+html: <details> <summary>Click to expand!</summary>
** Part 1

#+begin_src emacs-lisp
  (defun laat/play-game (init end history)
    (cl-loop for x in init
             for i from 1
             do (puthash x (list i) history))

    (cl-loop with last = (car (last init))
             for i from (+ 1 (length init)) to end
             do (let* ((seen (gethash last history))
                       (prev1 (car seen))
                       (prev2 (cadr seen))
                       (next-value (if prev2 (- prev1 prev2) 0)))
                  (puthash next-value (list i (car (gethash next-value history))) history)
                  (setf last next-value))
             finally return last))
#+end_src

#+RESULTS:
: laat/play-game

#+begin_src emacs-lisp :exports both
 (laat/play-game '(0 8 15 2 12 1 4) 2020 (make-hash-table :test 'equal))
#+end_src

#+RESULTS:
: 289

** Part 2 - The garbage collector

With the algorithm from Part 1 it takes 3 minutes to run and write the result into this file. However! Emacs hangs for an additional 20 minutes when collecting the garbage produced by the algorithm.

If you dare, you can collect the garbage first =M-x garbage-collect= and then run the algorithm:

#+begin_src emacs-lisp :exports both :eval never
 (laat/play-game '(0 8 15 2 12 1 4) 30000000 (make-hash-table :test 'equal))
#+end_src

#+RESULTS:
: 1505722

And finally run =M-x garbage-collect= again (if not triggered automatically), and observe that it takes a **very** long time to become responsive again.

*** The fix

To fix this, I've created an algorithm that does not allocate that much memory during each iteration of the loop, and reuses as much as possible. It's about as fast, but does not hang during garbage collection once it's done.

#+begin_src emacs-lisp :eval never
  (defun laat/play-game2 (init end)
    (let* ((size (max end (+ 1 (apply 'max init))))
           (history (make-vector size nil)))
      (cl-loop for x in init
               for i from 1
               do (aset history x i))
      (cl-loop with lastSpoken = (car (last init))
               for turn from (+ 1 (length init)) to end
               do (let* ((prev (aref history lastSpoken))
                         (next (if prev (- turn 1 prev) 0)))
                    (aset history lastSpoken (- turn 1))
                    (setf lastSpoken next))
               finally return lst)))
#+end_src

#+begin_src emacs-lisp :exports both :eval never
 (laat/play-game2 '(0 8 15 2 12 1 4) 30000000)
#+end_src

#+RESULTS:
: 1505722

#+html: </details>
* Day 14
#+html: <details> <summary>Click to expand!</summary>

@@html:<a name="day-14-part-1">@@
@@html:</a>@@
** Part 1

With this example:

#+name: example
#+begin_example
mask = XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
mem[8] = 11
mem[7] = 101
mem[8] = 0
#+end_example

Parse the program

#+begin_src emacs-lisp
  (defun laat/parse-line (s)
    (pcase s
      ((rx "mask = " (group (+ anything)))
       (list :mask (match-string 1 s)))
      ((rx "mem[" (group (+ digit)) "] = " (group (+ digit)))
       (list :put (string-to-number (match-string 1 s))
             :val (string-to-number (match-string 2 s))))))

  (defun laat/parse-program (program)
    (->> program
         (s-trim)
         (s-lines)
         (-map 'laat/parse-line)))
#+end_src

#+RESULTS:
: laat/parse-program

#+begin_src emacs-lisp :exports results :var example=example
  ;; print example "ast"
  (mapcar (lambda (s) (list (format "%s"s)))
          (laat/parse-program example))
#+end_src

#+RESULTS:
| (:mask XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X) |
| (:put 8 :val 11)                             |
| (:put 7 :val 101)                            |
| (:put 8 :val 0)                              |

#+begin_src emacs-lisp
  (defun laat/make-masker (mask-str)
    (->> mask-str
         (reverse)
         (seq-map-indexed
          (lambda (c i)
            (pcase c
              (`?1 `(lambda (x) (logior x ,(ash 1 i))))
              (`?0 `(lambda (x) (logand x ,(lognot (ash 1 i))))))))
         (-non-nil)
         (apply '-compose)))
#+end_src

#+RESULTS:
: laat/make-masker

#+begin_src emacs-lisp :exports none
  (list
   (funcall (laat/make-masker "XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X") 11)
   (funcall (laat/make-masker "XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X") 101)
   (funcall (laat/make-masker "XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X") 0))
#+end_src

#+RESULTS:
| 73 | 101 | 64 |

#+begin_src emacs-lisp :var example=example :exports code
  (defun laat/exec-program (program-str)
    (let ((mem (make-hash-table :test 'equal))
          (mask 'identity)
          (instructions (laat/parse-program program-str)))
      (cl-loop for instruction in instructions
               do (pcase instruction
                    (`(:mask ,mask-str)
                     (setf mask (laat/make-masker mask-str)))
                    (`(:put ,loc :val ,val)
                     (puthash loc (funcall mask val) mem))))
      (cl-loop for val being the hash-values of mem
               sum val)))
#+end_src

#+RESULTS:
: laat/exec-program

#+begin_src emacs-lisp :exports none :var example=example
  (laat/exec-program example)
#+end_src

#+RESULTS:
: 165

#+begin_src emacs-lisp :exports both
  (laat/exec-program (laat/read-file "data/14.txt"))
#+end_src

#+RESULTS:
: 14925946402938

@@html:<a name="day-14-part-2">@@
@@html:</a>@@
** Part 2

*** The address finder

#+begin_src emacs-lisp
  (defun laat/make-address-finder (mask-str)
    (->> mask-str
         (reverse)
         (seq-map-indexed
          (lambda (c i)
            (pcase c
              (?1 `(lambda (xs)
                     (-map (lambda (x) (logior x ,(ash 1 i))) xs)))
              (?X `(lambda (xs)
                     (append (-map (lambda (x) (logior x ,(ash 1 i))) xs)
                             (-map (lambda (x) (logand x ,(lognot (ash 1 i)))) xs)))))))
         (-non-nil)
         (apply '-compose)))
#+end_src

#+RESULTS:
: laat/make-address-finder

The first example works
#+begin_src emacs-lisp :exports both
  (-sort '< (funcall (laat/make-address-finder "000000000000000000000000000000X1001X") '(42)))
#+end_src

#+RESULTS:
| 26 | 27 | 58 | 59 |

The second example works
#+begin_src emacs-lisp :exports both
  (-sort '< (funcall (laat/make-address-finder "00000000000000000000000000000000X0XX") '(26)))
#+end_src

#+RESULTS:
| 16 | 17 | 18 | 19 | 24 | 25 | 26 | 27 |

*** Execute

#+begin_src emacs-lisp :var example=example :exports both
  (defun laat/exec-program (program-str)
    (let ((mem (make-hash-table :test 'equal))
          (lookup-address 'identity)
          (instructions (laat/parse-program program-str)))
       (cl-loop for instruction in instructions
                do (pcase instruction
                     (`(:mask ,mask-str)
                      (setf lookup-address (laat/make-address-finder mask-str)))
                     (`(:put ,loc :val ,val)
                      (cl-loop for address in (funcall lookup-address `(,loc))
                               do (puthash address val mem)))))
       (cl-loop for val being the hash-values of mem
                sum val)))

  (laat/exec-program (laat/read-file "data/14.txt"))
#+end_src

#+RESULTS:
: 3706820676200


#+html: </details>
* Day 13

#+html: <details> <summary>Click to expand!</summary>

** Part 1

#+begin_src emacs-lisp :exports both
  (require 'dash)
  (let* ((data (laat/read-lines "data/13.txt"))
         (target (string-to-number (car data)))
         (routes (mapcar 'string-to-number (remove-if (lambda (x) (equal x "x")) (split-string (cadr data) ","))))
         (nexts (mapcar (lambda (r) (list r (* r (+ 1 (/ target r))))) routes))
         (next (--min-by (> (cadr it) (cadr other)) nexts) ))
  (* (car next) (- (cadr next) target)))
#+end_src

#+RESULTS:
: 2305


** Part 2 - Lazy Edition
Solving the problem by using the online solver available at https://davidwees.com/chineseremaindertheorem/.

But it must be solved in org-mode (this file). To do that I'm controlling Firefox with emacs to paste the data into the form and get the result.

*** Parse data

#+begin_src emacs-lisp :exports both
  (defun laat/read-pattern (file-name)
    (let* ((data (seq-map-indexed 'list (split-string (cadr (laat/read-lines file-name)) ",")))
           (data2 (cl-remove-if (lambda (x) (equal "x" (car x))) data)))
      (mapcar (lambda (x) (list (cadr x) (string-to-number (car x)))) data2)))

  (laat/read-pattern "data/13-example.txt")
#+end_src

#+RESULTS:
| 0 |  7 |
| 1 | 13 |
| 4 | 59 |
| 6 | 31 |
| 7 | 19 |

*** Create modulo equations for CRT

[[https://en.wikipedia.org/wiki/Chinese_remainder_theorem][Chinese remainder theorem]]

#+begin_src emacs-lisp :exports both
  (defun laat/to-modulo-equation (the-route)
    (pcase-let* ((`(,offset ,route) the-route)
                 (a (- route offset)))
      (cl-loop while (< a 0)
               do (setf a (+ a route)))
      (format "x = %s mod %s" a route)))

  (defun laat/to-modulo-equations (routes)
    (string-join (mapcar 'laat/to-modulo-equation routes) "\n"))

  (laat/to-modulo-equations (laat/read-pattern "data/13-example.txt"))
#+end_src

#+RESULTS:
: x = 7 mod 7
: x = 12 mod 13
: x = 55 mod 59
: x = 25 mod 31
: x = 12 mod 19

*** Controlling Firefox

Install [[https://github.com/xuchunyang/marionette.el][marionette.el]] using [[https://github.com/jwiegley/use-package][use-package]] and [[https://github.com/quelpa][quelpa]]

#+begin_src emacs-lisp
  (use-package marionette
    :quelpa
    (marionette
     :fetcher github
     :repo "xuchunyang/marionette.el"
     :commit "516bbcec25edbaf0feaf3aad3e442d581881c5ee"))
#+end_src

Open Firefox with marionette protocol enabled on OS X:

#+begin_src shell :eval never
open -a Firefox --args -marionette
#+end_src

The solver function:

#+begin_src emacs-lisp
  (defun $select (proc selector)
    (cdadr (assoc 'value (marionette-request
                          proc 'FindElement
                          :value selector :using "css selector"))))
  (defun laat/solve-crt (equations)
    (marionette-with-page
     (lambda (proc)
       ;; goto solver
       (marionette-request
        proc 'Navigate
        :url "https://davidwees.com/chineseremaindertheorem/")

       ;; insert text
       (marionette-request
        proc 'ElementSendKeys
        :id ($select proc "#equations")
        :text equations)

       ;; click submit
       (marionette-request
        proc 'ElementClick
        :id ($select proc "input[type=submit]"))

       ;; get solution
       (let ((res (marionette-request
                   proc 'GetElementProperty
                   :id ($select proc "#solution")
                   :name "value")))
         (cdr (assoc 'value res))))))

#+end_src

*** Solve the example

Example

#+begin_src emacs-lisp :exports both
  (thread-last (laat/read-pattern "data/13-example.txt")
    (laat/to-modulo-equations)
    (laat/solve-crt))
#+end_src

#+RESULTS:
: 1068781

*** Solves my problem?

My data

#+begin_src emacs-lisp :exports both
(laat/read-file "data/13.txt")
#+end_src

#+RESULTS:
: 1001287
: 13,x,x,x,x,x,x,37,x,x,x,x,x,461,x,x,x,x,x,x,x,x,x,x,x,x,x,17,x,x,x,x,19,x,x,x,x,x,x,x,x,x,29,x,739,x,x,x,x,x,x,x,x,x,41,x,x,x,x,x,x,x,x,x,x,x,x,23

My data becomes these equations:

#+name: my-equations
#+begin_src emacs-lisp :exports both
  (thread-last (laat/read-pattern "data/13.txt")
    (laat/to-modulo-equations))
#+end_src

#+RESULTS: my-equations
: x = 13 mod 13
: x = 30 mod 37
: x = 448 mod 461
: x = 7 mod 17
: x = 6 mod 19
: x = 16 mod 29
: x = 695 mod 739
: x = 28 mod 41
: x = 2 mod 23

The website solves it as:

#+begin_src emacs-lisp :exports both
  (thread-last (laat/read-pattern "data/13.txt")
    (laat/to-modulo-equations)
    (laat/solve-crt))
#+end_src

#+RESULTS:
: 552612234243418

[[./day-13-part-2.gif]]

This is *wrong*! There is a rounding error.

*** Let's fix the rounding error

By using =BigInt= instead of =Number=. The lines I've changed are marked with =//<--=.

#+begin_src js :var myEquations=my-equations :exports both
  // a copy of the js source at
  // https://davidwees.com/chineseremaindertheorem/
  function calculate(equations) {
      equations = equations.replace(/ /g, '');
      equations = equations.toLowerCase();
      equations = equations.split(/\n/);
      if (equations[equations.length - 1] == '') {
          equations.pop();
      }
      var regmod = /mod([0-9]*)/;
      var rega = /=([0-9]*)mod/;
      var N = BigInt(1);                                               // <--
      var matches;
      var n = new Array();
      var a = new Array();
      var e = new Array();
      var tmp;
      var x = BigInt(0);                                               // <--
      for (var i = 0; i < equations.length; i++) {
          matches = regmod.exec(equations[i]);
          N = BigInt(matches[1]) * N;                                  // <--
          n[i] = BigInt(matches[1]);                                   // <--
          matches = rega.exec(equations[i]);
          a[i] = BigInt(matches[1]);                                   // <--
      }

      var max = BigInt(1);                                             // <--
      for (var i in n) {
          max = n[i] * max;
      }

      for (i = 0; i < equations.length; i++) {
          tmp = extended_gcd(n[i], N / n[i]);
          e[i] = (tmp[1] * N) / n[i];
      }
      for (i = 0; i < equations.length; i++) {
          x += e[i] * a[i];
      }
      if (x >= max) {
          x = x % max;
      }

      while (x < 0) {
          x = x + max;
      }

      return x;
  }

  function extended_gcd(a, b) {
      if (a % b == 0) {
          var temp = new Array(BigInt(0), BigInt(1));                  // <--
          return temp;
      } else {
          var temp = extended_gcd(b, a % b);
          var temp2 = new Array(temp[1], temp[0] - temp[1] * (a / b)); // <--
          return temp2;
      }
  }

  return calculate(myEquations)
#+end_src

#+RESULTS:
: 552612234243498n

*correct*


#+html: </details>
* Day 12
#+html: <details> <summary>Click to expand!</summary>

#+begin_src emacs-lisp
  (defun laat/parse-line (str)
    (when (string-match "\\([A-Z]+\\)\\([0-9]+\\)" str)
      (list (match-string 1 str) (string-to-number (match-string 2 str)))))
#+end_src

#+RESULTS:
: laat/parse-line

** Part 1

#+begin_src emacs-lisp :exports both
  (defun laat/rotation (deg)
    (pcase (mod (/ deg 360.0) 1.0)
      (`0.25 '(1 0))
      (`0.5  '(0 -1))
      (`0.75 '(-1 0))
      (`0.0  '(0 1))
      (`-0.0 '(0 1))))

  (defun laat/calc-ne (north east deg lines)
    (pcase lines
      (`nil (list north east))
      (_ (pcase-let*
             ((rot (laat/rotation deg))
              (`((,instruction ,n)) lines)
              (dn (* (car rot) n))
              (de (* (cadr rot) n))
              (rest (cdr lines)))
           (pcase instruction
             (`"N" (laat/calc-ne (+ north n) east deg rest))
             (`"S" (laat/calc-ne (- north n) east deg rest))
             (`"E" (laat/calc-ne north (+ east n) deg rest))
             (`"W" (laat/calc-ne north (- east n) deg rest))
             (`"F" (laat/calc-ne (+ north dn) (+ east de) deg rest))
             (`"R" (laat/calc-ne north east (- deg n) rest))
             (`"L" (laat/calc-ne north east (+ deg n) rest)))))))

  (thread-last (laat/read-lines "data/12.txt")
    (mapcar 'laat/parse-line)
    (laat/calc-ne 0 0 0)
    (mapcar 'abs)
    (apply '+))
#+end_src

#+RESULTS:
: 521

** Part 2

#+begin_src emacs-lisp :exports both
  (defun laat/rotate (n e dir deg)
    (let ((deg* (cond ((equal dir "R") (* -1 deg))
                      ((equal dir "L") deg)
                      (t 0))))
      (pcase (mod (/ deg* 360.0) 1.0)
        (`0.25 (list e (* -1 n)))
        (`0.5  (list (* -1 n) (* -1 e)))
        (`0.75 (list (* -1 e) n))
        (`0.0  (list n e)))))

  (defun laat/calc-ne-wp (north east x y lines)
    (pcase lines
      (`nil (list north east))
      (_ (pcase-let*
             ((`((,instruction ,n)) lines)
              (`(,rx ,ry) (laat/rotate x y instruction n))
              (dx (* x n))
              (dy (* y n))
              (rest (cdr lines)))
           (pcase instruction
             (`"N" (laat/calc-ne-wp north east (+ x n) y rest))
             (`"S" (laat/calc-ne-wp north east (- x n) y rest))
             (`"E" (laat/calc-ne-wp north east x (+ y n) rest))
             (`"W" (laat/calc-ne-wp north east x (- y n) rest))
             (`"F" (laat/calc-ne-wp (+ north dx) (+ east dy) x y rest))
             (`"R" (laat/calc-ne-wp north east rx ry rest))
             (`"L" (laat/calc-ne-wp north east rx ry rest)))))))

  (thread-last (laat/read-lines "data/12.txt")
    (mapcar 'laat/parse-line)
    (laat/calc-ne-wp 0 0 1 10)
    (mapcar 'abs)
    (apply '+))
#+end_src

#+RESULTS:
: 22848

#+html: </details>

* Day 11
#+html: <details> <summary>Click to expand!</summary>

#+begin_src emacs-lisp :exports no
  (defun laat/printable-layout (layout)
    (cl-loop for line across layout
             collect (cl-loop for s across line
                              collect (cond ((eq nil s) ".")
                                            ((eq :taken s) "#")
                                            ((eq :empty s) "L")))))
#+end_src

#+RESULTS:
: laat/printable-layout

** Part 1

⚠️ Slow!

#+begin_src emacs-lisp :exports both
  (defun laat/make-adjacent-square (row col layout)
    (cl-loop for i from (- row 1) to (+ row 1)
             append (cl-loop for j from (- col 1) to (+ col 1)
                             unless (or (and (eq row i) (eq col j))
                                        (> 0 i)
                                        (> 0 j)
                                        (<= (length (aref layout 0)) j)
                                        (<= (length layout) i))
                             collect (list i j))))

  (defun laat/count-taken (layout)
    (cl-loop for (i j) in (laat/cross (laat/range (length layout))
                                      (laat/range (length (aref layout 0))))
             count (eq :taken (aref (aref layout i) j))))
  (defun laat/count-adjacent (i j layout)
    (cl-loop for (i j) in (laat/make-adjacent-square i j layout)
             count (eq :taken (aref (aref layout i) j))))

  (defun laat/mutate-layout (layout)
    (let ((next-layout (copy-tree layout t))
          (squares (laat/cross (laat/range (length layout))
                               (laat/range (length (aref layout 0))))))
      (cl-loop for (i j) in squares
               when (and (eq (aref (aref layout i) j) :taken)
                         (<= 4 (laat/count-adjacent i j layout)))
               do (aset (aref next-layout i) j :empty))

      (cl-loop for (i j) in squares
               when (and (eq (aref (aref layout i) j) :empty)
                         (eq 0 (laat/count-adjacent i j layout)))
               do (aset (aref next-layout i) j :taken))
      next-layout))

  (defun laat/mutate-until-done (layout)
    (cl-loop with count-end = 0 ;; after the do block
             while (not (eq count-end count-start))
             for count-start = (laat/count-taken layout) ;; before the do block
             do (setf layout (laat/mutate-layout layout))
             do (setf count-end (laat/count-taken layout))
             finally return layout))

  (thread-last (laat/read-lines "data/11.txt")
    (mapcar (lambda (line) (mapcar (lambda (c) (cond ((eq c ?L) :empty))) line)))
    (mapcar (lambda (row) (mapcar (lambda (s) (cond ((eq s :empty) :taken))) row)))
    (mapcar (lambda (row) (apply 'vector row)))
    ((lambda (x) (apply 'vector x)))
    (laat/mutate-until-done)
    (laat/count-taken))
#+end_src

#+RESULTS:
: 2346

** Part 2

⚠️ Super Slow!

I fell a sleep after 30 minutes of running. It's slooooow as hek but works.

#+begin_src emacs-lisp :exports both
  (defun laat/count-direction (row col di dj layout)
    (let ((maxi (length layout))
          (maxj (length (elt layout 0))))
      (cl-loop for k in (laat/range (max maxi maxj))
               for i = (+ (* k di) row)
               for j = (+ (* k dj) col)
               unless (< i 0)
               unless (>= i maxi)
               unless (< j 0)
               unless (>= j maxj)
               unless (and (eq row i) (eq col j))
               for el = (elt (elt layout i) j)
               when (not (eq el nil))
               return (cond ((eq el :taken) 1)
                            ((eq el :empty) 0))
               finally return 0)))

  (defun laat/count-directions (row col layout)
    (cl-loop for (di dj) in '((+1 0) (-1 0) (0 +1) (0 -1)
                              (-1 -1) (+1 -1) (+1 +1) (-1 +1))
             sum (laat/count-direction row col di dj layout)))

  (defun laat/mutate-layout (layout)
    (let ((next-layout (copy-tree layout t))
          (squares (laat/cross (laat/range (length layout))
                               (laat/range (length (aref layout 0))))))
      (cl-loop for (i j) in squares
               when (and (eq (aref (aref layout i) j) :taken)
                         (<= 5 (laat/count-directions i j layout)))
               do (aset (aref next-layout i) j :empty))

      (cl-loop for (i j) in squares
               when (and (eq (aref (aref layout i) j) :empty)
                         (eq 0 (laat/count-directions i j layout)))
               do (aset (aref next-layout i) j :taken))
      next-layout))

  (defun laat/mutate-until-done (layout)
    (cl-loop with count-end = 0 ;; after the mutation
             while (not (eq count-end count-start))
             for count-start = (laat/count-taken layout) ;; before the mutation
             do (setf layout (laat/mutate-layout layout))
             do (setf count-end (laat/count-taken layout))
             finally return layout))

  (thread-last (laat/read-lines "data/11.txt")
    (mapcar (lambda (line) (mapcar (lambda (c) (cond ((eq c ?L) :empty))) line)))
    (mapcar (lambda (row) (mapcar (lambda (s) (cond ((eq s :empty) :taken))) row)))
    (mapcar (lambda (row) (apply 'vector row)))
    ((lambda (x) (apply 'vector x)))
    (laat/mutate-until-done)
    (laat/count-taken))
#+end_src

#+RESULTS:
: 2111



#+html: </details>

* Day 10
#+html: <details> <summary>Click to expand!</summary>

** Part 1
#+begin_src emacs-lisp :exports both
  (let* ((data (mapcar 'string-to-number (laat/read-lines "data/10.txt")))
         (numbers (sort (cons 0 (cons (+ 3 (apply 'max data)) data)) '<))
         (pairs (cl-mapcar #'list numbers (cl-rest numbers)))
         (diffs (mapcar (lambda (xs) (- (cadr xs) (car xs))) pairs)))
    (* (cl-count-if (lambda (n) (eq n 3)) diffs)
       (cl-count-if (lambda (n) (eq n 1)) diffs)))
#+end_src

#+RESULTS:
: 2516

** Part 2

#+begin_src emacs-lisp :exports both
  (require 'cl-lib)

  (defun laat/get-next-plugs (current numbers)
    (cl-loop for next in numbers
             when (and (> next current) (<= next (+ 3 current)))
             collect next))

  (defun laat/count-paths-to-sink (n sink numbers mem)
    (cond
     ((eq sink n) 1)
     ((gethash n mem) (gethash n mem)) ;; already counted
     (t (puthash n (apply '+ (mapcar (lambda (c) (laat/count-paths-to-sink c sink numbers mem))
                                     (laat/get-next-plugs n numbers)))
                 mem))))

  (let* ((data (mapcar 'string-to-number (laat/read-lines "data/10.txt")))
         (sink (+ 3 (apply 'max data)))
         (numbers (cons sink data)))
    (laat/count-paths-to-sink 0 sink numbers
                              (make-hash-table :test 'eq)))
#+end_src

#+RESULTS:
: 296196766695424


#+html: </details>
* Day 9
#+html: <details> <summary>Click to expand!</summary>

** Part 1

#+name: day-9-1
#+begin_src emacs-lisp :exports both
  (require 'cl-lib)

  (defun laat/cartesian-product (a b)
    (mapcan (lambda (x) (mapcar (lambda (y) (list x y)) b)) a))

  (defun laat/aoc-valid-xmas (pre n numbers)
    (let* ((preamble (cl-subseq numbers n (+ n pre)))
           (valid-sums (mapcar (lambda (xs) (apply '+ xs))
                               (cl-remove-if (lambda (xs) (eq (car xs) (cadr xs)))
                                             (laat/cartesian-product preamble preamble))))
           (test (nth (+ n pre) numbers)))
      (member test valid-sums)))

  (cl-loop with data = (mapcar 'string-to-number (laat/read-lines "data/9.txt"))
           with preamble = 25
           for i below (- (length data) preamble)
           until (not (laat/aoc-valid-xmas preamble i data))
           finally return (list :i (+ i preamble) :value (nth (+ i preamble) data)))
#+end_src

#+RESULTS: day-9-1
| :i | 562 | :value | 144381670 |

** Part 2

#+begin_src emacs-lisp :var part1=day-9-1 :exports both
  (defun laat/has-sum (needle numbers)
    (cl-loop for n in numbers
             collect n into res1
             sum n into res2
             until (>= res2 needle)
             finally return (cond ((eq res2 needle) res1))))

  (cl-loop with numbers = (mapcar 'string-to-number (laat/read-lines "data/9.txt"))
           with needle = (plist-get part1 :value)
           with needle-i = (plist-get part1 :i)
           for i below needle-i
           for r = (laat/has-sum needle (cl-subseq numbers i needle-i))
           until r
           finally return (+ (apply 'max r) (apply 'min r)))

#+end_src

#+RESULTS:
: 20532569

#+html: </details>
* Day 8
#+html: <details> <summary>Click to expand!</summary>

#+begin_src emacs-lisp
  ;; elisp does not have TCO. Cheating
  (setq max-lisp-eval-depth 10000)
  (setq max-specpdl-size 32000)

  (defun laat/aoc-exec (index acc prog visited)
    (cond ((>= index (length prog)) (list :terminated acc))
          ((gethash index visited) (list :loop acc ))
          (t
           (puthash index t visited)
           (seq-let (inst v) (nth index prog)
             (cond ((equal inst "nop") (laat/aoc-exec (+ 1 index) acc prog visited))
                   ((equal inst "acc") (laat/aoc-exec (+ 1 index) (+ v acc) prog visited))
                   ((equal inst "jmp") (laat/aoc-exec (+ v index) acc prog visited)))))))

  (defun laat/aoc-parse-program (file-name)
    (mapcar (lambda (line) (seq-let (inst value) (split-string line " ")
                             (list inst (string-to-number value))))
            (laat/read-lines file-name)))
#+end_src

#+RESULTS:
: laat/aoc-parse-program


** Part 1

#+begin_src emacs-lisp :exports both
  (laat/aoc-exec 0 0 (laat/aoc-parse-program "data/8.txt") (make-hash-table :test 'equal))
#+end_src

#+RESULTS:
| :loop | 1600 |

** Part 2

#+begin_src emacs-lisp :exports both
  (defun laat/swap-instruction (index program)
    (let* ((copy (copy-tree program))
           (line (nth index copy))
           (inst (car line)))
      (cond ((equal inst "nop") (setf (car line) "jmp"))
            ((equal inst "jmp") (setf (car line) "nop")))
      copy))

  (let ((program (laat/aoc-parse-program "data/8.txt")))
    (cl-loop for i below (length program)
             for insts = (laat/swap-instruction i program)
             for res = (laat/aoc-exec 0 0 insts (make-hash-table :test 'equal))
             until (equal (car res) :terminated)
             finally return (nth 1 res)))

#+end_src

#+RESULTS:
: 1543

#+html: </details>
* Day 7
#+html: <details> <summary>Click to expand!</summary>

#+begin_src emacs-lisp
  (defun laat/aoc-get-root-bag (str)
    (when (string-match "\\(.*\\) bag" str)
      (match-string 1 str)))

  (defun laat/aoc-get-child-bag (str)
    (when (string-match "\\([0-9]+\\) \\(.*\\) bag\\(s\\)?" str)
      (list (match-string 2 str) (string-to-number (match-string 1 str)))))

  (defun laat/aoc-parse-edges (str)
    (let* ((parts (mapcan (lambda (s) (split-string s "contain")) (split-string str ",")))
           (root (laat/aoc-get-root-bag (car parts)))
           (contents (mapcar 'laat/aoc-get-child-bag (cdr parts))))
      (mapcar (lambda (c) (cons root c)) contents)))
#+end_src

#+RESULTS:
: laat/aoc-parse-edges


** Part 1

#+begin_src emacs-lisp :exports both
  (require 'cl-lib)

  (defun laat/aoc-make-backwards-graph (edges)
    (cl-loop with graph = (make-hash-table :test 'equal)
             for (parent child) in edges
             when child
             do (puthash child (cons parent (gethash child graph)) graph)
             finally return graph))

  (defun laat/search-graph (bag graph)
    (append (gethash bag graph)
            (mapcan (lambda (c) (laat/search-graph c graph))
                    (gethash bag graph))))

  (thread-last (laat/read-lines "data/7.txt")
    (mapcan 'laat/aoc-parse-edges)
    (laat/aoc-make-backwards-graph)
    (laat/search-graph "shiny gold")
    (cl-remove-duplicates)
    (length))

#+end_src

#+RESULTS:
: 155

** Part 2

#+begin_src emacs-lisp :exports both
  (require 'cl-lib)

  (defun laat/aoc-make-weighted-graph (edges)
    (cl-loop with graph = (make-hash-table :test 'equal)
             for (parent child weight) in edges
             when weight
             do (puthash parent (cons (list child weight) (gethash parent graph)) graph)
             finally return graph))

  (defun laat/aoc-count-bags (bag graph)
    (cl-loop for (child weight) in (gethash bag graph)
             sum (* weight (laat/aoc-count-bags child graph)) into count
             finally return (+ 1 count)))

  (thread-last (laat/read-lines "data/7.txt")
    (mapcan 'laat/aoc-parse-edges)
    (laat/aoc-make-weighted-graph)
    (laat/aoc-count-bags "shiny gold")
    (+ -1))
#+end_src

#+RESULTS:
: 54803

#+html: </details>
* Day 6
#+html: <details> <summary>Click to expand!</summary>

** Part 1

#+begin_src emacs-lisp :exports both
  (require 'cl-lib)
  (thread-last (split-string (laat/read-file "data/6.txt") "\n\n")
    (mapcar (lambda (group) (apply 'concat (split-string group "\n"))))
    (mapcar 'cl-remove-duplicates)
    (mapcar 'length)
    (apply '+))
#+end_src

#+RESULTS:
: 6630

** Part 2

#+begin_src emacs-lisp :exports both
  (require 'cl-lib)
  (defun laat/aoc-count-everyone-said-yes (group)
    (thread-last (split-string group "\n")
      (mapcar 'string-to-list)
      (cl-remove-if-not 'identity)
      (cl-reduce 'cl-intersection)
      (length)))

  (thread-last (split-string (laat/read-file "data/6.txt") "\n\n")
    (mapcar 'laat/aoc-count-everyone-said-yes)
    (apply '+))
#+end_src

#+RESULTS:
: 3437

#+html: </details>
* Day 5
#+html: <details> <summary>Click to expand!</summary>

#+begin_src emacs-lisp
  (defun laat/aoc-seat-to-int (pass)
    (thread-last pass
      (reverse)
      (mapcar
       (lambda (c)
         (cond ((equal c ?F) 0)
               ((equal c ?B) 1)
               ((equal c ?L) 0)
               ((equal c ?R) 1))))
      (seq-map-indexed 'ash)
      (apply '+)))
#+end_src

#+RESULTS:
: laat/aoc-seat-to-int


#+begin_src emacs-lisp :exports both
  (list (laat/aoc-seat-to-int "FBFBBFFRLR")
        (laat/aoc-seat-to-int "BFFFBBFRRR")
        (laat/aoc-seat-to-int "FFFBBBFRRR")
        (laat/aoc-seat-to-int "BBFFBBFRLL"))
#+end_src

#+RESULTS:
| 357 | 567 | 119 | 820 |

** Part 1

#+begin_src emacs-lisp :exports both
  (thread-last "data/5.txt"
    (laat/read-lines)
    (mapcar 'laat/aoc-seat-to-int)
    (apply 'max))
#+end_src

#+RESULTS:
: 951

** Part 2

Set difference

#+begin_src emacs-lisp :exports both
  (let* ((seats (sort (mapcar 'laat/aoc-seat-to-int (laat/read-lines "data/5.txt")) '<))
         (candidates (cdr (butlast seats)))
         (candidates2 (mapcar (lambda (n) (+ 1 n)) (butlast seats 2))))
    (- (car (seq-difference candidates candidates2)) 1))
#+end_src

#+RESULTS:
: 653

Pairwise

#+begin_src emacs-lisp :exports both
  (require 'cl-lib)
  (let* ((seats (sort (mapcar 'laat/aoc-seat-to-int (laat/read-lines "data/5.txt")) '<))
         (pairs (cl-mapcar #'list seats (cl-rest seats)))
         (missing (car (cl-remove-if (lambda (xs) (equal (+ 1 (car xs)) (nth 1 xs))) pairs))))
    (+ 1 (car missing)))
#+end_src

#+RESULTS:
: 653

#+html: </details>
* Day 4
#+html: <details> <summary>Click to expand!</summary>

#+begin_src emacs-lisp
    (defun laat/aoc-read-passport-strings (file-path)
      (with-temp-buffer
        (insert-file-contents file-path)
        (split-string (buffer-string) "\n\n" t)))

    (defun laat/aoc-read-passport (passport-s)
      (let ((elements (split-string passport-s "[ \n]" t))
            (props (make-hash-table :test 'equal)))
        (progn
          (dolist (el elements)
            (let ((parts (split-string el ":" t)))
              (puthash (car parts) (nth 1 parts) props))))
        props))
#+end_src

#+RESULTS:
: laat/aoc-read-passport

** Part 1

#+begin_src emacs-lisp :exports both
    (require 'cl-lib)

    (defun laat/aoc-is-passport-valid-1-p (passport)
      (and
       (gethash "byr" passport)
       (gethash "iyr" passport)
       (gethash "eyr" passport)
       (gethash "hgt" passport)
       (gethash "hcl" passport)
       (gethash "ecl" passport)
       (gethash "pid" passport)
       ;; (gethash "cid" passport)
       ))

  (thread-last "data/4-1.txt"
    laat/aoc-read-passport-strings
    (mapcar 'laat/aoc-read-passport)
    (cl-remove-if-not 'laat/aoc-is-passport-valid-1-p)
    length)
#+end_src

#+RESULTS:
: 242

** Part 2

#+begin_src emacs-lisp :exports both
  (require 'cl-lib)

  (defun laat/aoc-byr-is-valid-p (passport)
    (when-let ((value (gethash "byr" passport)))
      (and (string-match-p "\\`[0-9]\\{4\\}\\'" value)
           (<= 1920 (string-to-number value))
           (>= 2002 (string-to-number value)))))

  (defun laat/aoc-iyr-is-valid-p (passport)
    (when-let ((value (gethash "iyr" passport)))
      (and (string-match-p "\\`[0-9]\\{4\\}\\'" value)
           (<= 2010 (string-to-number value))
           (>= 2020 (string-to-number value)))))

  (defun laat/aoc-eyr-is-valid-p (passport)
    (when-let ((value (gethash "eyr" passport)))
      (and (string-match-p "\\`[0-9]\\{4\\}\\'" value)
           (<= 2020 (string-to-number value))
           (>= 2030 (string-to-number value)))))

  (defun laat/aoc-hgt-is-valid-p (passport)
    (when-let ((value (gethash "hgt" passport)))
      (or (and (string-match-p "\\`[0-9]+cm\\'" value)
               (<= 150 (string-to-number value))
               (>= 193 (string-to-number value)))
          (and (string-match-p "\\`[0-9]+in\\'" value)
               (<= 59 (string-to-number value))
               (>= 76 (string-to-number value))))))

  (defun laat/aoc-hcl-is-valid-p (passport)
    (when-let ((value (gethash "hcl" passport)))
      (string-match-p "\\`\#[0-9a-f]\\{6\\}\\'" value)))

  (defun laat/aoc-ecl-is-valid-p (passport)
    (let ((value (gethash "ecl" passport)))
      (member value '("amb" "blu" "brn" "gry" "grn" "hzl" "oth"))))

  (defun laat/aoc-pid-is-valid-p (passport)
    (when-let ((value (gethash "pid" passport)))
      (string-match-p "\\`[0-9]\\{9\\}\\'" value)))

  (defun laat/aoc-is-passport-valid-2-p (passport)
    (and (laat/aoc-byr-is-valid-p passport)
         (laat/aoc-iyr-is-valid-p passport)
         (laat/aoc-eyr-is-valid-p passport)
         (laat/aoc-hgt-is-valid-p passport)
         (laat/aoc-hcl-is-valid-p passport)
         (laat/aoc-ecl-is-valid-p passport)
         (laat/aoc-pid-is-valid-p passport)))

  (thread-last "data/4-1.txt"
    laat/aoc-read-passport-strings
    (mapcar 'laat/aoc-read-passport)
    (cl-remove-if-not 'laat/aoc-is-passport-valid-2-p)
    length)
#+end_src

#+RESULTS:
: 186

#+html: </details>
* Day 3
#+html: <details> <summary>Click to expand!</summary>

#+begin_src emacs-lisp
  (defun laat/aoc-read-forest (filePath)
    (mapcar
     (lambda (line)
       (let ((trees (mapcar (lambda (c) (if (equal ?# c) 1 0)) line)))
         (nconc trees trees))) ;; circular list where 1 is tree
     (laat/read-lines filePath)))
#+end_src

#+RESULTS:
: laat/aoc-read-forest

** Part 1


#+begin_src emacs-lisp :exports both
  (thread-last (laat/aoc-read-forest "data/3-1.txt")
    (seq-map-indexed (lambda (trees i) (nth (* i 3) trees)))
    (apply '+))
#+end_src

#+RESULTS:
: 242

** Part 2

#+begin_src emacs-lisp :exports both
  (defun laat/aoc-count-slope (down right)
    (thread-last (laat/aoc-read-forest "data/3-1.txt")
      (seq-map-indexed
       (lambda (trees i) (if (eq (% i down) 0) (nth (* (/ i down) right) trees) 0)))
      (apply '+)))

  (thread-last '((1 1) (1 3) (1 5) (1 7) (2 1))
    (mapcar (lambda (slope) (laat/aoc-count-slope (car slope) (nth 1 slope))))
    (apply '*))
#+end_src

#+RESULTS:
: 2265549792


#+html: </details>
* Day 2
#+html: <details> <summary>Click to expand!</summary>

#+begin_src emacs-lisp
  (defun laat/aoc-read-passwords-line (line)
    (let* ((parts (split-string line ": "))
           (rule-parts (split-string (car parts) " "))
           (min-max (mapcar 'string-to-number (split-string (car rule-parts) "-")))
           (min (car min-max))
           (max (nth 1 min-max))
           (character (car (last rule-parts)))
           (password (string-join (cdr parts) " ")))
      (list
       :min min
       :max max
       :character character
       :password password)))

  (defun laat/aoc-read-passwords-file (filePath)
    (mapcar 'laat/aoc-read-passwords-line (laat/read-lines filePath)))
#+end_src

#+RESULTS:
: laat/aoc-read-passwords-file

** Part 1

#+begin_src emacs-lisp :exports both
  (require 'cl-lib)

  (defun laat/aoc-2-1-is-passowrd-valid-p (line)
    (let* ((character (plist-get line :character))
           (max (plist-get line :max))
           (min (plist-get line :min))
           (password (plist-get line :password))
           (occurances (- (length (split-string password character)) 1)))
      (and (<= min occurances) (>= max occurances))))

  (length
   (cl-remove-if-not
    'laat/aoc-2-1-is-passowrd-valid-p
    (laat/aoc-read-passwords-file "data/2-1.txt")))

#+end_src

#+RESULTS:
: 398

** Part 2

#+begin_src emacs-lisp :exports both
  (require 'cl-lib)

  (defun laat/aoc-2-2-is-passowrd-valid-p (line)
    (let* ((character (plist-get line :character))
           (a (- (plist-get line :min) 1))
           (b (- (plist-get line :max) 1))
           (password (plist-get line :password))
           (a-is-char-p (equal character (substring password a (+ a 1))))
           (b-is-char-p (equal character (substring password b (+ b 1)))))
      (xor a-is-char-p b-is-char-p)))

  (length
   (cl-remove-if-not
    'laat/aoc-2-2-is-passowrd-valid-p
     (laat/aoc-read-passwords-file "data/2-1.txt")))
#+end_src

#+RESULTS:
: 562

#+html: </details>
* Day 1

#+html: <details> <summary>Click to expand!</summary>
#+begin_src emacs-lisp
  (defun laat/aoc-read-numbers-file (filePath)
    "read file as a list of newline separated numbers"
    (mapcar 'string-to-number (laat/read-lines filePath)))
#+end_src

#+RESULTS:
: laat/aoc-read-numbers-file

** Part 1

=- 2020= trick

#+begin_src emacs-lisp :exports both
  (require 'cl-lib)

  (defun laat/aoc-1-1 (xs)
    (apply '* (cl-intersection (mapcar (lambda (arg) (- 2020 arg)) xs) xs)))

  (laat/aoc-1-1 (laat/aoc-read-numbers-file "data/1-1.txt"))
#+end_src

#+RESULTS:
: 658899

cl-loop

#+begin_src emacs-lisp :exports both
  (require 'cl-lib)

  (let* ((data (laat/aoc-read-numbers-file "data/1-1.txt"))
         (pairs (mapcan (lambda (a) (mapcar (lambda (b) (list a b)) data)) data)))
    (car (cl-loop for (x y) in pairs
                  when (eq 2020 (+ x y))
                  collect (* x y))))

#+end_src

#+RESULTS:
: 658899

** Part 2

#+begin_src emacs-lisp :exports both
  (require 'cl-lib)

  (defun laat/aoc-1-2 (xs)
    (apply '*
           (car
            (cl-remove-if
             (lambda (x) (not (equal (apply '+ x) 2020)))
             (mapcan
              (lambda (a)
                (mapcan
                 (lambda (b)
                   (mapcar (lambda (c) (list a b c)) xs))
                 xs))
              xs)))))

  (laat/aoc-1-2 (laat/aoc-read-numbers-file "data/1-1.txt"))
#+end_src

#+RESULTS:
: 155806250
#+html: </details>
