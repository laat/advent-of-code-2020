#+title: Advent Of Code 2020

Using [[https://orgmode.org/][org-mode]] and Emacs Lisp to solve Advent of Code.

* helpers

#+begin_src emacs-lisp
  (defun laat/sum (numbers) (apply '+ numbers))
  (defun laat/product (numbers) (apply '* numbers))
  (defun laat/read-lines (file-nname)
    (with-temp-buffer
      (insert-file-contents filePath)
      (split-string (buffer-string) "\n" t)))
#+end_src

* Day 1

#+begin_src emacs-lisp
  (defun laat/aoc-read-numbers-file (filePath)
    "read file as a list of newline separated numbers"
    (mapcar 'string-to-number (laat/read-lines filePath)))
#+end_src

** Part 1

#+begin_src emacs-lisp
  (require 'cl-lib)

  (defun laat/aoc-1-1 (xs)
    (laat/product (cl-intersection (mapcar (lambda (arg) (- 2020 arg)) xs) xs)))

  (laat/aoc-1-1 (laat/aoc-read-numbers-file "1-1.txt"))
#+end_src

** Part 2

#+begin_src emacs-lisp
  (require 'cl-lib)

  (defun laat/aoc-1-2 (xs)
    (laat/product
     (car
      (cl-remove-if
       (lambda (x) (not (equal (apply '+ x) 2020)))
       (mapcan
        (lambda (a)
          (mapcan
           (lambda (b)
             (mapcar
              (lambda (c) (list a b c)) xs)) xs)) xs)))))

  (laat/aoc-1-2 (laat/aoc-read-numbers-file "1-1.txt"))
#+end_src

* Day 2

#+begin_src emacs-lisp
  (defun laat/aoc-read-passwords-line (line)
    (let* ((parts (split-string line ": "))
           (rule-parts (split-string (car parts) " "))
           (min-max (mapcar 'string-to-number (split-string (car rule-parts) "-")))
           (min (car min-max))
           (max (nth 1 min-max))
           (character (car (last rule-parts)))
           (password (string-join (cdr parts) " ")))
      (list
       :min min
       :max max
       :character character
       :password password)))

  (defun laat/aoc-read-passwords-file (filePath)
    (mapcar 'laat/aoc-read-passwords-line (laat/read-lines filePath)))
#+end_src

** Part 1

#+begin_src emacs-lisp
  (require 'cl-lib)

  (defun laat/aoc-2-1-is-passowrd-valid-p (line)
    (let* ((character (plist-get line :character))
           (max (plist-get line :max))
           (min (plist-get line :min))
           (password (plist-get line :password))
           (occurances (- (length (split-string password character)) 1)))
      (and (<= min occurances) (>= max occurances))))

  (length
   (cl-remove-if-not
    'laat/aoc-2-1-is-passowrd-valid-p
    (laat/aoc-read-passwords-file "2-1.txt")))

#+end_src

** Part 2

#+begin_src emacs-lisp
  (require 'cl-lib)

  (defun laat/aoc-2-2-is-passowrd-valid-p (line)
    (let* ((character (plist-get line :character))
           (a (- (plist-get line :min) 1))
           (b (- (plist-get line :max) 1))
           (password (plist-get line :password))
           (a-is-char-p (equal character (substring password a (+ a 1))))
           (b-is-char-p (equal character (substring password b (+ b 1)))))
      (xor a-is-char-p b-is-char-p)))

  (length
   (cl-remove-if-not
    'laat/aoc-2-2-is-passowrd-valid-p
     (laat/aoc-read-passwords-file "2-1.txt")))
#+end_src

* Day 3

#+begin_src emacs-lisp
  (defun laat/aoc-read-forest (filePath)
    (mapcar
     (lambda (line)
       (let ((trees (mapcar (lambda (c) (if (equal ?# c) 1 0)) line)))
         (nconc trees trees))) ;; circular list where 1 is tree
     (laat/read-lines filePath)))
#+end_src

** Part 1


#+begin_src emacs-lisp
  (laat/sum
   (seq-map-indexed
    (lambda (trees i) (nth (* i 3) trees))
    (laat/aoc-read-forest "3-1.txt")))
#+end_src

** Part 2

#+begin_src emacs-lisp
  (defun laat/aoc-count-slope (down right)
    (laat/sum
     (seq-map-indexed
      (lambda (trees i) (if (eq (% i down) 0) (nth (* (/ i down) right) trees) 0))
      (laat/aoc-read-forest "3-1.txt"))))

  (laat/product
   (mapcar
    (lambda (slope) (laat/aoc-count-slope (car slope) (nth 1 slope)))
    '((1 1) (1 3) (1 5) (1 7) (2 1))))
#+end_src


* Day 4

#+begin_src emacs-lisp
    (defun laat/aoc-read-passport-strings (file-path)
      (with-temp-buffer
        (insert-file-contents file-path)
        (split-string (buffer-string) "\n\n" t)))

    (defun laat/aoc-read-passport (passport-s)
      (let ((elements (split-string passport-s "[ \n]" t))
            (props (make-hash-table :test 'equal)))
        (progn
          (dolist (el elements)
            (let ((parts (split-string el ":" t)))
              (puthash (car parts) (nth 1 parts) props))))
        props))
#+end_src

** Part 1

#+begin_src emacs-lisp
    (require 'cl-lib)

    (defun laat/aoc-is-passport-valid-1-p (passport)
      (and
       (gethash "byr" passport)
       (gethash "iyr" passport)
       (gethash "eyr" passport)
       (gethash "hgt" passport)
       (gethash "hcl" passport)
       (gethash "ecl" passport)
       (gethash "pid" passport)
       ;; (gethash "cid" passport)
       ))

    (length
     (cl-remove-if-not
      'laat/aoc-is-passport-valid-1-p
      (mapcar
       'laat/aoc-read-passport
       (laat/aoc-read-passport-strings "4-1.txt"))))

#+end_src

** Part 2

#+begin_src emacs-lisp
  (require 'cl-lib)

  (defun laat/matches-p (regex value)
    (and value (string-match-p regex value)))

  (defun laat/aoc-byr-is-valid-p (passport)
    (let ((value (gethash "byr" passport)))
      (and
       (laat/matches-p "\\`[0-9]\\{4\\}\\'" value)
       (<= 1920 (string-to-number value))
       (>= 2002 (string-to-number value)))))

  (defun laat/aoc-iyr-is-valid-p (passport)
    (let ((value (gethash "iyr" passport)))
      (and
       (laat/matches-p "\\`[0-9]\\{4\\}\\'" value)
       (<= 2010 (string-to-number value))
       (>= 2020 (string-to-number value)))))

  (defun laat/aoc-eyr-is-valid-p (passport)
    (let ((value (gethash "eyr" passport)))
      (and
       (laat/matches-p "\\`[0-9]\\{4\\}\\'" value)
       (<= 2020 (string-to-number value))
       (>= 2030 (string-to-number value)))))

  (defun laat/aoc-hgt-is-valid-p (passport)
    (let ((value (gethash "hgt" passport)))
      (or (and (laat/matches-p "\\`[0-9]+cm\\'" value)
               (<= 150 (string-to-number value))
               (>= 193 (string-to-number value)))
          (and (laat/matches-p "\\`[0-9]+in\\'" value)
               (<= 59 (string-to-number value))
               (>= 76 (string-to-number value))))))

  (defun laat/aoc-hcl-is-valid-p (passport)
    (let ((value (gethash "hcl" passport)))
      (laat/matches-p "\\`\#[0-9a-f]\\{6\\}\\'" value)))

  (defun laat/aoc-ecl-is-valid-p (passport)
    (let ((value (gethash "ecl" passport)))
      (member value '("amb" "blu" "brn" "gry" "grn" "hzl" "oth"))))

  (defun laat/aoc-pid-is-valid-p (passport)
    (let ((value (gethash "pid" passport)))
      (and value (string-match-p "\\`[0-9]\\{9\\}\\'" value))))

  (defun laat/aoc-is-passport-valid-2-p (passport)
    (and
     (laat/aoc-byr-is-valid-p passport)
     (laat/aoc-iyr-is-valid-p passport)
     (laat/aoc-eyr-is-valid-p passport)
     (laat/aoc-hgt-is-valid-p passport)
     (laat/aoc-hcl-is-valid-p passport)
     (laat/aoc-ecl-is-valid-p passport)
     (laat/aoc-pid-is-valid-p passport)))

  (length
   (cl-remove-if-not
    'laat/aoc-is-passport-valid-2-p
    (mapcar
     'laat/aoc-read-passport
     (laat/aoc-read-passport-strings "4-1.txt"))))
#+end_src
